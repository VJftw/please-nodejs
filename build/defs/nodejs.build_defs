"""
"""

def nodejs_toolchain(
    name: str,
    version: str,
    visibility: list = ["PUBLIC"],
):
    arch = ""
    if CONFIG.ARCH == "amd64":
        arch = "x64"
    else:
        fail(f"Unsupported architecture: {CONFIG.ARCH}")

    download=remote_file(
        name = f"{name}#download",
        url = f"https://nodejs.org/dist/v{version}/node-v{version}-{CONFIG.OS}-{arch}.tar.xz",
        extract = True,
        visibility = visibility,
    )

    venv=genrule(
        name = name,
        srcs = [download],
        outs = [name],
        cmd = """
mv $SRCS $OUTS

cat <<EOF > $OUTS/venv.sh
    DIR="\\\$( cd "\\\$( dirname "\\\${BASH_SOURCE[0]}" )" && pwd )"
    export PATH="\\\$DIR/bin:$PATH"
    echo "added \\\$DIR/bin to the path"
EOF
source $OUTS/venv.sh
        """,
        visibility = visibility,
    )

def nodejs_esbuild_toolchain(
    name: str,
    version: str,
    visibility: list = ["PUBLIC"],
):
    arch = ""
    if CONFIG.ARCH == "amd64":
        arch = "64"
    else:
        fail(f"Unsupported architecture: {CONFIG.ARCH}")

    remote_file(
        name = name,
        url = f"https://registry.npmjs.org/esbuild-{CONFIG.OS}-{arch}/-/esbuild-{CONFIG.OS}-{arch}-{version}.tgz",
        extract = True,
        binary = True,
        visibility = visibility,
        exported_files = [
            "package/bin/esbuild",
        ],
    )

def nodejs_npm_package(
    name: str,
    package_name: str = None,
    version: str,
    license: str = None,
    registry: str = None,
    toolchain: str = None,
    visibility = ["PUBLIC"],
    deps: list = [],
):
    if not package_name:
        package_name = name

    if not toolchain and not CONFIG.NODEJS.DEFAULT_TOOLCHAIN:
        fail("no 'toolchain' or 'nodejs.DefaultToolchain' specified.")
    toolchain = toolchain or CONFIG.NODEJS.DEFAULT_TOOLCHAIN

    if not registry and not CONFIG.NODEJS.DEFAULT_NPM_REGISTRY:
        fail("no 'registry' or 'nodejs.DefaultNPMRegistry' specified.")

    registry = registry or CONFIG.NODEJS.DEFAULT_NPM_REGISTRY

    please_nodejs_tool = CONFIG.NODEJS.TOOL
    pnpm_tool = CONFIG.NODEJS.PNPM_TOOL

    # npm packages can't have '*'s in them, so we can use that as a replacement
    # for the directory separator.
    safe_package_name=package_name.replace("/", "*")

    genrule(
        name = name,
        tools = [
            please_nodejs_tool,
            toolchain,
            pnpm_tool,
        ],
        deps = deps,
        cmd = f"""
        set -Eeuo pipefail
        source $(location {toolchain})/venv.sh
        pnpm="$(exe //third_party/binary:pnpm)"

        "$pnpm" store add {package_name}@{version}

        # verify that dependencies are available
        "$(exe {please_nodejs_tool})" \\
            --log_format=console \\
            npmpackagedeps \\
            --registry="{registry}" \\
            --name="{package_name}" \\
            --version="{version}"

        safe_pkg_name="$(echo "{package_name}" | sed 's#/#_#g')"
        tar -czf $safe_pkg_name-{version}.tgz .local .cache
        mv $safe_pkg_name-{version}.tgz $OUTS
        """,
        outs = [f"{safe_package_name}@{version}.tgz"],
        visibility = visibility,
        exported_deps = deps,
    )

def nodejs_package_json(
    name: str,
    deps: list = [],
):
    please_nodejs_tool = CONFIG.NODEJS.TOOL

    return genrule(
        name = name,
        deps = deps,
        needs_transitive_deps = True,
        tools = [please_nodejs_tool],
        outs = [f"{name}_package.json"],
        cmd = f"""
        set -Eeuo pipefail
        "$(exe {please_nodejs_tool})" \\
            --log_format=console \\
            packagejson \\
            --out="$OUTS"
        """,
    )

def nodejs_node_modules(
    name: str,
    package_json: str,
    toolchain: str,
    deps: list = [],
):
    pnpm_tool = CONFIG.NODEJS.PNPM_TOOL

    return genrule(
        name = name,
        srcs = {
            "package_json": [package_json],
        },
        needs_transitive_deps = True,
        sandbox = True,
        tools = [
            toolchain,
            pnpm_tool,
        ],
        outs = [name],
        deps = deps,
        cmd = f"""
        set -Eeuo pipefail

        source $(location {toolchain})/venv.sh
        pnpm="$(exe {pnpm_tool})"

        find . -name '*.tgz' -exec tar -xzf {{}} \;

        mv $SRCS_PACKAGE_JSON package.json
        "$pnpm" install --offline

        mv node_modules $OUTS
        """,
    )

def nodejs_esbuild_bundle(
    name: str,
    srcs: list = [],
    deps: list = [],
    esbuild_args: list = [],
    browser: bool = False,
    browsers: list = ["chrome58","firefox57","safari11","edge16"],
    toolchain: str,
):
    if browser:
        browser_flag=",".join(browsers)
        esbuild_args+=["--minify", "--sourcemap", f"--target={browser_flag}"]

    if not browser:
        deps += [CONFIG.NODEJS.VERCEL_PKG_DEP]

    package_json = nodejs_package_json(
        name = tag(name, "package_json"),
        deps = deps,
    )

    node_modules=nodejs_node_modules(
        name = tag(name, "node_modules"),
        package_json = package_json,
        deps = deps,
        toolchain = toolchain,
    )

    # Build w/ esbuild.
    esbuild_args_cmd=" ".join(esbuild_args)
    extra_cmds=""
    if not browser:
        genrule(
            name = name,
            srcs = {
                "package_json": [package_json],
                "node_modules": [node_modules],
                "srcs": srcs,
                "pkg_cache": ["//third_party/nodejs:node-v18.5.0-linux-x64"],
            },
            tools = [
                "//third_party/nodejs:esbuild",
                f"{toolchain}",
            ],
            outs = [name],
            cmd = f"""
set -Eeuo pipefail
mv $SRCS_PACKAGE_JSON package.json
mv $SRCS_NODE_MODULES node_modules
$(exe //third_party/nodejs:esbuild) \\
    --bundle {esbuild_args_cmd} \\
    --outfile=out.js \\
    $SRCS_SRCS

source $(location {toolchain})/venv.sh
mkdir -p ~/.pkg-cache/v3.4/
mv $SRCS_PKG_CACHE ~/.pkg-cache/v3.4/fetched-v18.5.0-linux-x64
npx pkg -t node18-linux-x64 out.js
mv out $OUTS
            """,
            binary = True,
            sandbox = True,
            # TODO: pre-populating cache for pkg without hardcoding in a separate build rule/build def.
        )
    else:
        genrule(
            name = name,
            sandbox = True,
            srcs = {
                "package_json": [package_json],
                "node_modules": [node_modules],
                "srcs": srcs,
            },
            tools = ["//third_party/nodejs:esbuild"],
            outs = [f"{name}.js"],
            cmd = f"""
set -Eeuo pipefail
mv $SRCS_PACKAGE_JSON package.json
mv $SRCS_NODE_MODULES node_modules
$TOOLS \\
    --bundle {esbuild_args_cmd} \\
    --outfile=$OUTS \\
    $SRCS_SRCS
            """,
        )
