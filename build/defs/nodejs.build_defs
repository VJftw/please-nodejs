"""
"""

def nodejs_toolchain(
    name: str,
    version: str,
    visibility: list = ["PUBLIC"],
):
    arch = ""
    if CONFIG.ARCH == "amd64":
        arch = "x64"
    else:
        fail(f"Unsupported architecture: {CONFIG.ARCH}")

    download=remote_file(
        name = f"{name}#download",
        url = f"https://nodejs.org/dist/v{version}/node-v{version}-{CONFIG.OS}-{arch}.tar.xz",
        extract = True,
        visibility = visibility,
    )

    # TODO: move to please_nodejs tool.
    venv=genrule(
        name = name,
        srcs = [download],
        outs = [name],
        cmd = """
mv $SRCS $OUTS

cat <<EOF > $OUTS/venv.sh
    DIR="\\\$( cd "\\\$( dirname "\\\${BASH_SOURCE[0]}" )" && pwd )"
    export PATH="\\\$DIR/bin:$PATH"
    echo "added \\\$DIR/bin to the path"
EOF
source $OUTS/venv.sh
        """,
        visibility = visibility,
    )

def nodejs_esbuild_toolchain(
    name: str,
    version: str,
    visibility: list = ["PUBLIC"],
):
    arch = ""
    if CONFIG.ARCH == "amd64":
        arch = "64"
    else:
        fail(f"Unsupported architecture: {CONFIG.ARCH}")

    remote_file(
        name = name,
        url = f"https://registry.npmjs.org/esbuild-{CONFIG.OS}-{arch}/-/esbuild-{CONFIG.OS}-{arch}-{version}.tgz",
        extract = True,
        binary = True,
        visibility = visibility,
        exported_files = [
            "package/bin/esbuild",
        ],
    )

def nodejs_npm_package(
    name: str,
    package_name: str = None,
    version: str,
    license: str = None,
    registry: str = "registry.npmjs.org", # TODO: replace w/ npm scopes.
    toolchain: str = None,
    visibility = ["PUBLIC"],
    deps: list = [],
):
    if not package_name:
        package_name = name

    if not toolchain and not CONFIG.NODEJS.DEFAULT_TOOLCHAIN:
        fail("no 'toolchain' or 'nodejs.DefaultToolchain' specified.")

    toolchain = toolchain or CONFIG.NODEJS.DEFAULT_TOOLCHAIN

    safe_package_name=package_name.replace("/", "_")

    # TODO: move to please_nodejs tool.
    genrule(
        name = name,
        tools = [
            toolchain,
            "//third_party/binary:jq",
            "//third_party/binary:pnpm",
        ],
        deps = deps,
        cmd = f"""
set -Eeuo pipefail
source $(location {toolchain})/venv.sh
jq="$(exe //third_party/binary:jq)"
pnpm="$(exe //third_party/binary:pnpm)"

"$pnpm" store add {package_name}@{version}

# verify that dependencies are available
mapfile -t dependencies_csv < <("$jq" -r \\
    '.versions["{version}"] | select(.dependencies != null) | .dependencies | to_entries[] | .key+","+.value' \\
    .cache/pnpm/metadata/{registry}/{package_name}.json
)

mapfile -t available_dependencies < <(find . -name '*.tgz' -exec basename {{}} \;)

for dependency_csv in "${{dependencies_csv[@]}}"; do
    dep_name="$(echo "$dependency_csv" | cut -f1 -d,)"
    safe_dep_name="$(echo "$dep_name" | sed 's#/#_#g')"
    dep_constraint="$(echo "$dependency_csv" | cut -f2- -d,)"

    if [[ ! " ${{available_dependencies[*]}} " =~ " ${{safe_dep_name}}"* ]]; then
        echo "
$dep_name ($dep_constraint) is missing from deps.
available deps:
$(printf '  %s\n' ${{available_dependencies[@]}})
        "
        exit 1
    fi
done

safe_pkg_name="$(echo "{package_name}" | sed 's#/#_#g')"

tar -czf $safe_pkg_name-{version}.tgz .local .cache

mv $safe_pkg_name-{version}.tgz $OUTS
        """,
        outs = [f"{safe_package_name}@{version}.tgz"],
        visibility = visibility,
        exported_deps = deps,
    )

def nodejs_esbuild_bundle(
    name: str,
    srcs: list = [],
    deps: list = [],
    esbuild_args: list = [],
    browser: bool = False,
    browsers: list = ["chrome58","firefox57","safari11","edge16"],
    toolchain: str,
):
    if browser:
        browser_flag=",".join(browsers)
        esbuild_args+=["--minify", "--sourcemap", f"--target={browser_flag}"]

    if not browser:
        deps += [CONFIG.NODEJS.VERCEL_PKG_DEP]

    # TODO: move to please_nodejs tool.
    package_json=genrule(
        name = f"{name}_package_json",
        deps = deps,
        needs_transitive_deps = True,
        tools = [
            "//third_party/binary:jq",
        ],
        outs = [f"{name}_package.json"],
        cmd = f"""
set -Eeuo pipefail
JQ=$(exe //third_party/binary:jq)

# add dependencies
echo '{{"dependencies": {{}}}}' > package.json
for srcs_dep in $(find . -name '*.tgz'); do
    # TODO: fix when pkgs start with an @
    pkg_file="$(echo "$srcs_dep" | xargs basename)"
    pkg_name=""
    pkg_version=""
    if [[ "$pkg_file" == "@"* ]]; then
        # scoped pkg
        pkg_name=""
        pkg_file="$(echo "$pkg_file" | cut -f2- -d\\@)"
        pkg_name="@$(echo "$pkg_file" | cut -f1 -d\\@ | sed 's#_#/#g')"
    else
        pkg_name="$pkg_name$(echo "$pkg_file" | cut -f1 -d\\@)"
    fi
    pkg_version="$(echo "$pkg_file" | cut -f2 -d\\@ | sed 's/.tgz//g')"

    $JQ \\
        --arg n "$pkg_name" \\
        --arg v "$pkg_version" \\
        '.dependencies[$n] = $v' \\
        package.json >> package.json.new
    mv package.json.new package.json
done

mv package.json $OUTS
        """,
    )

    # TODO: move to please_nodejs tool.
    node_modules=genrule(
        name = f"{name}_node_modules",
        srcs = {
            "package_json": [package_json],
        },
        needs_transitive_deps = True,
        sandbox = True,
        tools = [
            f"{toolchain}",
            "//third_party/binary:pnpm",
        ],
        outs = [f"{name}_node_modules"],
        deps = deps,
        cmd = f"""
set -Eeuo pipefail

source $(location {toolchain})/venv.sh
pnpm="$(exe //third_party/binary:pnpm)"

find . -name '*.tgz' -exec tar -xzf {{}} \;

mv $SRCS_PACKAGE_JSON package.json
"$pnpm" install --offline

mv node_modules $OUTS
        """,
    )

    # Build w/ esbuild.
    esbuild_args_cmd=" ".join(esbuild_args)
    extra_cmds=""
    if not browser:
        genrule(
            name = name,
            srcs = {
                "package_json": [package_json],
                "node_modules": [node_modules],
                "srcs": srcs,
                "pkg_cache": ["//third_party/nodejs:node-v18.5.0-linux-x64"],
            },
            tools = [
                "//third_party/nodejs:esbuild",
                f"{toolchain}",
            ],
            outs = [name],
            cmd = f"""
set -Eeuo pipefail
mv $SRCS_PACKAGE_JSON package.json
mv $SRCS_NODE_MODULES node_modules
$(exe //third_party/nodejs:esbuild) \\
    --bundle {esbuild_args_cmd} \\
    --outfile=out.js \\
    $SRCS_SRCS

source $(location {toolchain})/venv.sh
mkdir -p ~/.pkg-cache/v3.4/
mv $SRCS_PKG_CACHE ~/.pkg-cache/v3.4/fetched-v18.5.0-linux-x64
npx pkg -t node18-linux-x64 out.js
mv out $OUTS
            """,
            binary = True,
            sandbox = True,
            # TODO: pre-populating cache for pkg without hardcoding in a separate build rule/build def.
        )
    else:
        genrule(
            name = name,
            srcs = {
                "package_json": [package_json],
                "node_modules": [node_modules],
                "srcs": srcs,
            },
            tools = ["//third_party/nodejs:esbuild"],
            outs = [f"{name}.js"],
            cmd = f"""
set -Eeuo pipefail
mv $SRCS_PACKAGE_JSON package.json
mv $SRCS_NODE_MODULES node_modules
$TOOLS \\
    --bundle {esbuild_args_cmd} \\
    --outfile=$OUTS \\
    $SRCS_SRCS
            """,
        )
